package controllers

import (
	"context"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"
	"k8s.io/client-go/kubernetes/scheme"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client/fake"

	cvev1 "cve-operator/api/v1"
)

func TestGitHubReleasesMonitorReconciler_Reconcile(t *testing.T) {
	// Register our custom resource
	s := scheme.Scheme
	s.AddKnownTypes(cvev1.GroupVersion, &cvev1.GitHubReleasesMonitor{})

	// Create a fake client
	monitor := &cvev1.GitHubReleasesMonitor{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "test-monitor",
			Namespace: "default",
		},
		Spec: cvev1.GitHubReleasesMonitorSpec{
			URL:         "https://api.github.com/repos/test/test/releases",
			MonitorFrom: "now",
			MonitorTo:   "now",
		},
	}
	cl := fake.NewClientBuilder().WithScheme(s).WithObjects(monitor).Build()

	// Create the reconciler with a mocked checkNewReleases function
	r := &GitHubReleasesMonitorReconciler{
		Client: cl,
		Scheme: s,
		checkNewReleasesFn: func(url string, since time.Time, until time.Time) ([]GitHubRelease, error) {  // Updated to match signature
			return []GitHubRelease{
				{TagName: "v1.0.0", CreatedAt: time.Now()},
				{TagName: "v1.1.0", CreatedAt: time.Now().Add(time.Hour)},
			}, nil
		},
	}

	// Run Reconcile
	req := ctrl.Request{
		NamespacedName: types.NamespacedName{
			Namespace: "default",
			Name:      "test-monitor",
		},
	}
	_, err := r.Reconcile(context.Background(), req)
	assert.NoError(t, err)

	// Check if the status was updated
	err = cl.Get(context.Background(), req.NamespacedName, monitor)
	assert.NoError(t, err)
	assert.Len(t, monitor.Status.Releases, 2)
	assert.False(t, monitor.Status.LastChecked.IsZero())
	assert.False(t, monitor.Status.MonitorFromTime.IsZero())
	// Removed the monitor.Status.MonitorToTime check since it's not used in status
}
